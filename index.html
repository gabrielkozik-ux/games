<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Optimalizace: Přidán meta description pro SEO -->
    <meta name="description" content="Zahrajte si klasické retro hry jako Snake, Pong, Tetris a další přímo ve vašem prohlížeči. Arkáda plná nostalgické zábavy.">
    <title>Retro Herní Arkáda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&family=Silkscreen&family=Bungee&display=swap" rel="stylesheet">
    <style>
        /* Custom fonts for games */
        body {
            font-family: 'Inter', sans-serif;
            transition: overflow 0.3s ease;
            overflow: auto; /* Ensure scrollbar is visible by default */
        }
        .font-press-start { font-family: 'Press Start 2P', cursive; }
        .font-vt323 { font-family: 'VT323', monospace; }
        .font-silkscreen { font-family: 'Silkscreen', cursive; }
        .font-bungee { font-family: 'Bungee', cursive; }

        /* Game window styles */
        .game-window {
            aspect-ratio: 4 / 3;
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 4px solid #1f2937;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.1);
            position: relative;
            /* Optimalizace: Reset pro <button> element */
            background: none;
            padding: 0;
            text-align: inherit;
        }
        /* Optimalizace: Vizuální zpětná vazba pro interaktivitu */
        .game-window:hover {
            transform: scale(1.03);
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3), 0 10px 10px -5px rgba(0,0,0,0.2);
        }
        /* Optimalizace: Zvýraznění pro ovládání klávesnicí */
        .game-window:focus-visible {
            outline: 4px solid #facc15; /* Bright yellow outline */
            outline-offset: 4px;
        }

        .game-window h2 {
            transition: opacity 0.3s ease;
        }
        .game-window canvas {
            display: none; /* Canvases are hidden by default */
            width: 100%;
            height: 100%;
        }
        .game-window.active h2 {
            display: none;
        }
        .game-window.active canvas {
            display: block;
        }
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10rem;
            color: white;
            -webkit-text-stroke: 4px black;
            text-stroke: 4px black;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        
        /* Thematic backgrounds */
        #snake-window { background-color: #a3e635; }
        #pong-window { background-color: #60a5fa; }
        #breakout-window { background-color: #facc15; }
        #dino-window { background-color: #d1d5db; }
        #invaders-window { background-color: #4c1d95; } /* Deep purple */
        #tetris-window { background-color: #fca5a5; } /* Light red */


        /* Prevent text selection */
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="bg-gray-800 text-white p-4 sm:p-8 flex flex-col min-h-screen noselect">
    <header class="text-center mb-4 sm:mb-8">
        <h1 class="text-4xl md:text-6xl font-bungee tracking-wider">Retro Herní Arkáda</h1>
        <!-- Optimalizace: Zvýšený kontrast pro lepší čitelnost -->
        <p class="text-gray-300 mt-2 font-vt323 text-xl">Klikni na hru pro spuštění / pauzu</p>
        <p class="text-gray-400 mt-4 font-vt323 text-lg">Příjemnou zábavu ti přeje Gabriel</p>
    </header>

    <main class="flex-grow grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-8">
        <!-- Optimalizace: Převod <div> na <button> pro přístupnost -->
        <button id="snake-window" class="game-window" data-game="snake">
            <h2 class="text-4xl md:text-5xl font-press-start text-gray-900">SNAKE</h2>
            <canvas id="snake-canvas"></canvas>
            <div class="countdown-overlay font-press-start"></div>
        </button>

        <button id="pong-window" class="game-window" data-game="pong">
            <h2 class="text-4xl md:text-5xl font-silkscreen text-gray-900">PONG</h2>
            <canvas id="pong-canvas"></canvas>
            <div class="countdown-overlay font-silkscreen"></div>
        </button>

        <button id="breakout-window" class="game-window" data-game="breakout">
            <h2 class="text-4xl md:text-5xl font-bungee text-gray-900">BREAKOUT</h2>
            <canvas id="breakout-canvas"></canvas>
            <div class="countdown-overlay font-bungee"></div>
        </button>
        
        <button id="dino-window" class="game-window" data-game="dino">
            <h2 class="text-4xl md:text-5xl font-vt323 text-gray-900">DINO RUN</h2>
            <canvas id="dino-canvas"></canvas>
            <div class="countdown-overlay font-vt323"></div>
        </button>

        <button id="invaders-window" class="game-window" data-game="invaders">
            <h2 class="text-4xl md:text-5xl font-press-start text-white text-center">SPACE INVADERS</h2>
            <canvas id="invaders-canvas"></canvas>
            <div class="countdown-overlay font-press-start"></div>
        </button>

        <button id="tetris-window" class="game-window" data-game="tetris">
            <h2 class="text-4xl md:text-5xl font-silkscreen text-gray-900">TETRIS</h2>
            <canvas id="tetris-canvas"></canvas>
            <div class="countdown-overlay font-silkscreen"></div>
        </button>
    </main>

    <footer class="mt-8 pt-6 border-t border-gray-700 text-center">
        <div class="flex flex-col md:flex-row items-center justify-center gap-6">
            <div class="text-left">
                <h3 class="font-bungee text-2xl text-yellow-400">Líbí se ti hry?</h3>
                <p class="text-gray-400 font-vt323 text-lg">Můžeš mi poděkovat koupí lahodné kávy.</p>
                <a href="https://buymeacoffee.com/gaboslovak" target="_blank" class="mt-2 inline-block bg-yellow-400 text-gray-900 font-bold py-2 px-4 rounded-lg hover:bg-yellow-300 transition-colors font-sans">
                    buymeacoffee.com/gaboslovak
                </a>
            </div>
            <div>
                <!-- Optimalizace: Přidány atributy width a height pro prevenci CLS -->
                <img src="bmc_qr.png" alt="QR kód pro Buy Me a Coffee" class="w-32 h-32 rounded-lg border-4 border-gray-600" width="128" height="128">
            </div>
        </div>
    </footer>
    
    <!-- Audio elements -->
    <audio id="snake-music" loop><source src="hadi-tanec.mp3" type="audio/mpeg"></audio>
    <audio id="pong-music" loop><source src="pong.mp3" type="audio/mpeg"></audio>
    <audio id="breakout-music" loop><source src="breakout.mp3" type="audio/mpeg"></audio>
    <audio id="dino-music" loop><source src="Dino-run.mp3" type="audio/mpeg"></audio>
    <audio id="invaders-music" loop><source src="space-invaders.mp3" type="audio/mpeg"></audio>
    <audio id="tetris-music" loop><source src="tetris.mp3" type="audio/mpeg"></audio>
    
    <audio id="game-over-sound"><source src="game-over.mp3" type="audio/mpeg"></audio>
    <audio id="ready-fight-sound"><source src="ready-fight.mp3" type="audio/mpeg"></audio>

    <script>
        // --- GLOBAL GAME CONTROLLER ---
        let activeGame = null;
        const gameInstances = {};
        const keysPressed = {};
        const gameOverSound = document.getElementById('game-over-sound');
        const readyFightSound = document.getElementById('ready-fight-sound');

        // --- GLOBAL KEY LISTENERS ---
        window.addEventListener('keydown', (e) => { keysPressed[e.key] = true; });
        window.addEventListener('keyup', (e) => { keysPressed[e.key] = false; });
        
        // --- GLOBAL FUNCTION for Game Over Sound ---
        function playGameOverSound() {
            // Stop any active game music
            if (activeGame && gameInstances[activeGame].music) {
                gameInstances[activeGame].music.pause();
                gameInstances[activeGame].music.currentTime = 0;
            }
            gameOverSound.currentTime = 0;
            gameOverSound.play();
            // Optimalizace: Vždy obnovit scrollbar po skončení hry
            document.body.style.overflow = 'auto';
        }

        // --- GLOBAL FUNCTION for Countdown ---
        function playCountdown(game, callback) {
            const overlay = game.canvas.nextElementSibling;
            let count = 2; // Countdown shortened to 2 seconds
            
            readyFightSound.currentTime = 0;
            readyFightSound.play();

            const interval = setInterval(() => {
                overlay.innerText = count;
                overlay.style.opacity = 1;
                setTimeout(() => { overlay.style.opacity = 0; }, 700);
                
                count--;
                if (count < 0) {
                    clearInterval(interval);
                    callback();
                }
            }, 1000);
        }

        // --- GAME IMPLEMENTATIONS ---

        // --- SNAKE ---
        gameInstances.snake = {
            canvas: document.getElementById('snake-canvas'),
            music: document.getElementById('snake-music'),
            ctx: null, tileSize: 20, snake: [], food: {}, direction: 'right', newDirection: 'right', score: 0, gameOver: false, paused: false, loop: null, lastUpdateTime: 0, updateInterval: 120,
            init() { this.ctx = this.canvas.getContext('2d'); this.reset(); window.addEventListener('keydown', this.handleInput.bind(this)); },
            reset() { 
                this.snake = [{ x: 10, y: 10 }]; 
                this.direction = 'right'; 
                this.newDirection = 'right'; 
                this.score = 0; 
                this.gameOver = false; 
                if(this.canvas.width > 0) this.placeFood();
                this.music.currentTime = 0;
            },
            placeFood() { const c = Math.floor(this.canvas.width / this.tileSize), r = Math.floor(this.canvas.height / this.tileSize); this.food = { x: Math.floor(Math.random() * c), y: Math.floor(Math.random() * r) }; },
            handleInput(e) { if (activeGame !== 'snake' || this.paused) return; if (e.key === 'ArrowUp' && this.direction !== 'down') this.newDirection = 'up'; else if (e.key === 'ArrowDown' && this.direction !== 'up') this.newDirection = 'down'; else if (e.key === 'ArrowLeft' && this.direction !== 'right') this.newDirection = 'left'; else if (e.key === 'ArrowRight' && this.direction !== 'left') this.newDirection = 'right'; },
            update() { 
                if (this.gameOver) { return; } 
                this.direction = this.newDirection; 
                const head = { ...this.snake[0] }; 
                if (this.direction === 'right') head.x++; 
                if (this.direction === 'left') head.x--; 
                if (this.direction === 'up') head.y--; 
                if (this.direction === 'down') head.y++; 
                const c = Math.floor(this.canvas.width / this.tileSize), r = Math.floor(this.canvas.height / this.tileSize); 
                if (head.x < 0 || head.x >= c || head.y < 0 || head.y >= r) { 
                    this.gameOver = true; 
                    playGameOverSound();
                    return; 
                } 
                for (let i = 1; i < this.snake.length; i++) { 
                    if (head.x === this.snake[i].x && head.y === this.snake[i].y) { 
                        this.gameOver = true; 
                        playGameOverSound();
                        return; 
                    } 
                } 
                this.snake.unshift(head); 
                if (head.x === this.food.x && head.y === this.food.y) { 
                    this.score++; 
                    this.placeFood(); 
                } else { 
                    this.snake.pop(); 
                } 
            },
            draw() { this.ctx.fillStyle = '#1a2e05'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#84cc16'; this.snake.forEach(seg => { this.ctx.fillRect(seg.x * this.tileSize, seg.y * this.tileSize, this.tileSize - 1, this.tileSize - 1); }); this.ctx.fillStyle = '#ef4444'; this.ctx.fillRect(this.food.x * this.tileSize, this.food.y * this.tileSize, this.tileSize, this.tileSize); this.ctx.fillStyle = 'white'; this.ctx.font = `${this.tileSize * 1.5}px "Press Start 2P"`; this.ctx.fillText(`Score: ${this.score}`, this.tileSize, this.tileSize * 2); if (this.gameOver) { this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); } },
            gameLoop(time) { if (!this.paused) { if (time - this.lastUpdateTime > this.updateInterval) { this.update(); this.lastUpdateTime = time; } this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.paused = false; this.lastUpdateTime = 0; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); this.music.play(); },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; this.music.pause(); },
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'hidden' : 'auto'; if (this.gameOver) this.start(); if (this.paused) this.music.pause(); else if (!this.gameOver) this.music.play(); }
        };

        // --- PONG ---
        gameInstances.pong = {
            canvas: document.getElementById('pong-canvas'), music: document.getElementById('pong-music'), ctx: null, ball: {}, player: {}, ai: {}, paddleWidth: 0, paddleHeight: 0, paused: false, loop: null, maxScore: 10, gameOver: false,
            init() { this.ctx = this.canvas.getContext('2d'); },
            reset() {
                this.paddleWidth = this.canvas.width / 80;
                this.paddleHeight = this.canvas.height / 6;
                this.ball = { x: this.canvas.width / 2, y: this.canvas.height / 2, size: this.canvas.width / 100, dx: 5, dy: 5 };
                this.player = { x: 10, y: this.canvas.height / 2 - this.paddleHeight / 2, width: this.paddleWidth, height: this.paddleHeight, score: 0, speed: 8 };
                this.ai = { x: this.canvas.width - 10 - this.paddleWidth, y: this.canvas.height / 2 - this.paddleHeight / 2, width: this.paddleWidth, height: this.paddleHeight, score: 0, speed: 4 };
                this.gameOver = false;
                this.music.currentTime = 0;
            },
            update() {
                if (this.paused || this.gameOver) return;
                if (keysPressed['ArrowUp']) this.player.y -= this.player.speed;
                if (keysPressed['ArrowDown']) this.player.y += this.player.speed;
                if (this.player.y < 0) this.player.y = 0;
                if (this.player.y + this.player.height > this.canvas.height) this.player.y = this.canvas.height - this.player.height;
                this.ball.x += this.ball.dx; this.ball.y += this.ball.dy;
                if (this.ball.y + this.ball.size > this.canvas.height || this.ball.y - this.ball.size < 0) this.ball.dy *= -1;
                if (this.ball.x - this.ball.size < this.player.x + this.player.width && this.ball.x > this.player.x && this.ball.y > this.player.y && this.ball.y < this.player.y + this.player.height) this.ball.dx *= -1.1;
                if (this.ball.x + this.ball.size > this.ai.x && this.ball.x < this.ai.x + this.ai.width && this.ball.y > this.ai.y && this.ball.y < this.ai.y + this.ai.height) this.ball.dx *= -1.1;
                if (this.ball.x + this.ball.size < 0) { this.ai.score++; this.resetBall(); }
                if (this.ball.x - this.ball.size > this.canvas.width) { this.player.score++; this.resetBall(); }
                const aiCenter = this.ai.y + this.ai.height / 2;
                if (aiCenter < this.ball.y - 35) this.ai.y += this.ai.speed;
                else if (aiCenter > this.ball.y + 35) this.ai.y -= this.ai.speed;
                if (this.ai.y < 0) this.ai.y = 0;
                if (this.ai.y + this.ai.height > this.canvas.height) this.ai.y = this.canvas.height - this.ai.height;
                if (this.player.score >= this.maxScore || this.ai.score >= this.maxScore) {
                    this.gameOver = true;
                    playGameOverSound();
                }
            },
            resetBall() { this.ball.x = this.canvas.width / 2; this.ball.y = this.canvas.height / 2; this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 5; this.ball.dy = (Math.random() > 0.5 ? 1 : -1) * 5; },
            draw() {
                this.ctx.fillStyle = '#0f172a'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.strokeStyle = 'rgba(255,255,255,0.2)'; this.ctx.beginPath(); this.ctx.moveTo(this.canvas.width / 2, 0); this.ctx.lineTo(this.canvas.width / 2, this.canvas.height); this.ctx.stroke();
                this.ctx.fillStyle = 'white'; this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height); this.ctx.fillRect(this.ai.x, this.ai.y, this.ai.width, this.ai.height);
                this.ctx.beginPath(); this.ctx.arc(this.ball.x, this.ball.y, this.ball.size, 0, Math.PI * 2); this.ctx.fill();
                this.ctx.font = `${this.canvas.width/15}px "Silkscreen"`; this.ctx.fillText(this.player.score, this.canvas.width / 4, 50); this.ctx.fillText(this.ai.score, this.canvas.width * 3 / 4, 50);
                if (this.gameOver) { this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); }
            },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); this.music.play();},
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; this.music.pause();},
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'hidden' : 'auto'; if (this.gameOver) this.start(); if (this.paused) this.music.pause(); else if (!this.gameOver) this.music.play(); }
        };

        // --- BREAKOUT ---
        gameInstances.breakout = {
            canvas: document.getElementById('breakout-canvas'), music: document.getElementById('breakout-music'), ctx: null, paddle: {}, balls: [], bricks: [], score: 0, lives: 3, paused: false, gameOver: false, loop: null,
            init() { this.ctx = this.canvas.getContext('2d'); },
            reset() {
                this.paddle = { x: this.canvas.width / 2 - 50, y: this.canvas.height - 20, width: 100, height: 10, speed: 10 };
                this.balls = [{ x: this.canvas.width / 2, y: this.canvas.height - 30, size: 7, dx: 4, dy: -4 }];
                this.createBricks(); this.score = 0; this.lives = 3; this.gameOver = false; this.music.currentTime = 0;
            },
            createBricks() { this.bricks = []; const rows = 5, cols = 8, padding = 2, brickWidth = (this.canvas.width - padding * (cols + 1)) / cols, brickHeight = 20; for (let c = 0; c < cols; c++) for (let r = 0; r < rows; r++) this.bricks.push({ x: c * (brickWidth + padding) + padding, y: r * (brickHeight + padding) + padding + 30, width: brickWidth, height: brickHeight, visible: true }); },
            update() {
                if (this.paused || this.gameOver) return;
                if (keysPressed['ArrowLeft']) this.paddle.x -= this.paddle.speed;
                if (keysPressed['ArrowRight']) this.paddle.x += this.paddle.speed;

                if (this.paddle.x < 0) this.paddle.x = 0;
                if (this.paddle.x + this.paddle.width > this.canvas.width) this.paddle.x = this.canvas.width - this.paddle.width;
                for (let i = this.balls.length - 1; i >= 0; i--) {
                    let ball = this.balls[i];
                    ball.x += ball.dx; ball.y += ball.dy;
                    if (ball.x + ball.size > this.canvas.width || ball.x - ball.size < 0) ball.dx *= -1;
                    if (ball.y - ball.size < 0) ball.dy *= -1;
                    if (ball.y + ball.size > this.canvas.height) { this.balls.splice(i, 1); if (this.balls.length === 0) { this.lives--; if (this.lives === 0) { this.gameOver = true; playGameOverSound(); } else { this.balls.push({ x: this.canvas.width / 2, y: this.canvas.height - 30, size: 7, dx: 4, dy: -4 }); } } }
                    if (ball.y + ball.size > this.paddle.y && ball.x > this.paddle.x && ball.x < this.paddle.x + this.paddle.width) { ball.dy *= -1; }
                    this.bricks.forEach(brick => { if (brick.visible && ball.x > brick.x && ball.x < brick.x + brick.width && ball.y > brick.y && ball.y < brick.y + brick.height) { brick.visible = false; ball.dy *= -1; this.score++; } });
                }
                if (this.bricks.every(b => !b.visible)) { this.createBricks(); this.balls.push({ x: this.canvas.width / 2, y: this.canvas.height / 2, size: 7, dx: 4, dy: -4 }); }
            },
            draw() {
                this.ctx.fillStyle = '#4a044e'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#fde047'; this.ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height);
                this.balls.forEach(ball => { this.ctx.beginPath(); this.ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2); this.ctx.fill(); });
                this.bricks.forEach((brick, i) => { if (brick.visible) { this.ctx.fillStyle = `hsl(${i * 360 / (5 * 8)}, 70%, 50%)`; this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height); } });
                this.ctx.fillStyle = 'white'; this.ctx.font = '20px "Bungee"'; this.ctx.fillText(`Score: ${this.score}`, 10, 25); this.ctx.fillText(`Lives: ${this.lives}`, this.canvas.width - 80, 25);
                if (this.gameOver) { this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); }
            },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); this.music.play();},
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; this.music.pause();},
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'hidden' : 'auto'; if (this.gameOver) this.start(); if (this.paused) this.music.pause(); else if (!this.gameOver) this.music.play(); }
        };

        // --- DINO RUN ---
        gameInstances.dino = {
            canvas: document.getElementById('dino-canvas'), music: document.getElementById('dino-music'), ctx: null, dino: {}, obstacles: [], gameSpeed: 5, gravity: 0.6, score: 0, frameCount: 0, paused: false, gameOver: false, loop: null,
            init() { this.ctx = this.canvas.getContext('2d'); this.reset(); window.addEventListener('keydown', this.handleInput.bind(this)); window.addEventListener('keyup', this.handleKeyUp.bind(this)); },
            reset() { this.dino = { x: 50, y: 0, width: 44, height: 47, dy: 0, jumpPower: 15, grounded: true, isDucking: false, runFrame: 0 }; this.obstacles = []; this.score = 0; this.gameSpeed = 5; this.gameOver = false; this.frameCount = 0; this.music.currentTime = 0; },
            handleInput(e) { if (activeGame !== 'dino' || this.paused) return; if ((e.key === ' ' || e.key === 'ArrowUp') && this.dino.grounded) { this.dino.dy = -this.dino.jumpPower; this.dino.grounded = false; } else if (e.key === 'ArrowDown') { this.dino.isDucking = true; } },
            handleKeyUp(e) { if (activeGame !== 'dino' || this.paused) return; if (e.key === 'ArrowDown') { this.dino.isDucking = false; } },
            update() {
                if (this.paused || this.gameOver) return;
                this.frameCount++; this.score++;
                this.dino.dy += this.gravity; this.dino.y += this.dino.dy;
                const groundY = this.canvas.height - 20;
                if (this.dino.y + this.dino.height > groundY) { this.dino.y = groundY - this.dino.height; this.dino.dy = 0; this.dino.grounded = true; }
                if (this.dino.isDucking) { this.dino.height = 25; } else { this.dino.height = 47; }
                if (this.frameCount % 5 === 0) { this.dino.runFrame = (this.dino.runFrame + 1) % 2; }
                if (this.frameCount % Math.max(30, (100 - this.gameSpeed * 5)) === 0 && Math.random() < 0.5) {
                    const type = Math.random() > 0.3 ? 'cactus' : 'bird';
                    if (type === 'cactus') { this.obstacles.push({ x: this.canvas.width, y: groundY - 50, width: 25, height: 50, type }); } 
                    else { this.obstacles.push({ x: this.canvas.width, y: groundY - (Math.random() > 0.5 ? 60 : 100), width: 45, height: 30, type, frame: 0 }); }
                }
                this.obstacles.forEach((obs, i) => {
                    obs.x -= this.gameSpeed;
                    if (obs.type === 'bird' && this.frameCount % 10 === 0) obs.frame = (obs.frame + 1) % 2;
                    if (obs.x + obs.width < 0) this.obstacles.splice(i, 1);
                    if (this.dino.x < obs.x + obs.width && this.dino.x + this.dino.width > obs.x && this.dino.y < obs.y + obs.height && this.dino.y + this.dino.height > obs.y) {
                        this.gameOver = true; playGameOverSound();
                    }
                });
                if (this.frameCount % 200 === 0) this.gameSpeed += 0.2;
            },
            drawDino() { const c = this.ctx; const d = this.dino; c.fillStyle = '#4b5563'; if (!this.dino.grounded) { c.fillRect(d.x, d.y, d.width, d.height); } else if (this.dino.isDucking) { c.fillRect(d.x, d.y, 58, d.height); } else { if (d.runFrame === 0) { c.fillRect(d.x, d.y, d.width, d.height); } else { c.fillRect(d.x, d.y, d.width, d.height); } } },
            drawCactus(obs) { this.ctx.fillStyle = '#166534'; this.ctx.fillRect(obs.x, obs.y, obs.width, obs.height); },
            drawBird(obs) { this.ctx.fillStyle = '#374151'; if (obs.frame === 0) { this.ctx.fillRect(obs.x, obs.y + 10, obs.width, 10); this.ctx.fillRect(obs.x + 10, obs.y, 20, obs.height); } else { this.ctx.fillRect(obs.x, obs.y, obs.width, 10); this.ctx.fillRect(obs.x + 10, obs.y + 10, 20, obs.height - 10); } },
            draw() {
                this.ctx.fillStyle = '#f3f4f6'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#4b5563'; this.ctx.fillRect(0, this.canvas.height - 20, this.canvas.width, 20);
                this.drawDino();
                this.obstacles.forEach(obs => { if (obs.type === 'cactus') this.drawCactus(obs); else this.drawBird(obs); });
                this.ctx.fillStyle = '#4b5563'; this.ctx.font = '24px "VT323"'; this.ctx.textAlign = 'right';
                this.ctx.fillText(`SCORE: ${Math.floor(this.score/5)}`, this.canvas.width - 20, 30);
                if (this.gameOver) { this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#f3f4f6'; this.ctx.font = '32px "VT323"'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); }
            },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); this.music.play();},
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; this.music.pause();},
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'hidden' : 'auto'; if (this.gameOver) this.start(); if (this.paused) this.music.pause(); else if (!this.gameOver) this.music.play(); }
        };

        // --- SPACE INVADERS ---
        gameInstances.invaders = {
            canvas: document.getElementById('invaders-canvas'), music: document.getElementById('invaders-music'), ctx: null, player: {}, bullets: [], invaders: [], invaderBullets: [], invaderDirection: 1, invaderSpeed: 0.5, score: 0, paused: false, gameOver: false, loop: null, lastShotTime: 0, shootCooldown: 300,
            init() { this.ctx = this.canvas.getContext('2d'); },
            reset() {
                this.player = { x: this.canvas.width / 2 - 25, y: this.canvas.height - 40, width: 50, height: 20, speed: 5 };
                this.bullets = []; this.invaderBullets = []; this.createInvaders(); this.score = 0; this.gameOver = false; this.music.currentTime = 0;
            },
            createInvaders() {
                this.invaders = []; const rows = 5; const cols = 10;
                const invaderWidth = this.canvas.width / 25; const invaderHeight = invaderWidth * 0.8;
                const invaderPadding = invaderWidth / 2; const totalRowWidth = cols * (invaderWidth + invaderPadding) - invaderPadding;
                const startX = (this.canvas.width - totalRowWidth) / 2; const startY = 30;
                for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { this.invaders.push({ x: startX + c * (invaderWidth + invaderPadding), y: startY + r * (invaderHeight + invaderPadding), width: invaderWidth, height: invaderHeight }); } }
            },
            update() {
                if (this.paused || this.gameOver) return;
                if (keysPressed['ArrowLeft'] && this.player.x > 0) this.player.x -= this.player.speed;
                if (keysPressed['ArrowRight'] && this.player.x + this.player.width < this.canvas.width) this.player.x += this.player.speed;
                if (keysPressed[' '] && Date.now() - this.lastShotTime > this.shootCooldown) {
                    this.bullets.push({ x: this.player.x + this.player.width / 2 - 2.5, y: this.player.y, width: 5, height: 10, dy: -7 });
                    this.lastShotTime = Date.now();
                }
                this.bullets.forEach((b, i) => { b.y += b.dy; if (b.y < 0) this.bullets.splice(i, 1); });
                this.invaderBullets.forEach((b, i) => {
                    b.y += b.dy;
                    if (b.y > this.canvas.height) this.invaderBullets.splice(i, 1);
                    if(b.x > this.player.x && b.x < this.player.x+this.player.width && b.y > this.player.y && b.y < this.player.y + this.player.height) {
                        this.gameOver = true; playGameOverSound();
                    }
                });
                let edgeReached = false;
                this.invaders.forEach(inv => {
                    inv.x += this.invaderSpeed * this.invaderDirection;
                    if (inv.x <= 0 || inv.x + inv.width >= this.canvas.width) edgeReached = true;
                    if (inv.y + inv.height > this.player.y) { this.gameOver = true; playGameOverSound(); }
                });
                if (edgeReached) { this.invaderDirection *= -1; this.invaders.forEach(inv => inv.y += 20); }
                if (Math.random() < 0.02 && this.invaders.length > 0) { const shooter = this.invaders[Math.floor(Math.random() * this.invaders.length)]; this.invaderBullets.push({ x: shooter.x + shooter.width / 2, y: shooter.y + shooter.height, width: 3, height: 7, dy: 4 }); }
                this.bullets.forEach((bullet, bIndex) => { this.invaders.forEach((invader, iIndex) => { if (bullet.x > invader.x && bullet.x < invader.x + invader.width && bullet.y > invader.y && bullet.y < invader.y + invader.height) { this.invaders.splice(iIndex, 1); this.bullets.splice(bIndex, 1); this.score += 10; } }); });
                if (this.invaders.length === 0) { this.createInvaders(); this.invaderSpeed += 0.2; }
            },
            draw() {
                this.ctx.fillStyle = '#000'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                this.ctx.fillStyle = '#fff'; this.bullets.forEach(b => this.ctx.fillRect(b.x, b.y, b.width, b.height));
                this.ctx.fillStyle = '#f00'; this.invaderBullets.forEach(b => this.ctx.fillRect(b.x, b.y, b.width, b.height));
                this.ctx.fillStyle = '#fff'; this.invaders.forEach(inv => this.ctx.fillRect(inv.x, inv.y, inv.width, inv.height));
                this.ctx.fillStyle = '#fff'; this.ctx.font = '20px "Press Start 2P"'; this.ctx.fillText(`Score: ${this.score}`, 10, 25);
                if (this.gameOver) { this.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); }
            },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); this.music.play();},
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; this.music.pause();},
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'hidden' : 'auto'; if (this.gameOver) this.start(); if (this.paused) this.music.pause(); else if (!this.gameOver) this.music.play(); }
        };

        // --- TETRIS ---
        gameInstances.tetris = {
            canvas: document.getElementById('tetris-canvas'), music: document.getElementById('tetris-music'), ctx: null, grid: [], score: 0, gameOver: false, paused: false, loop: null, dropCounter: 0, dropInterval: 1000, lastTime: 0, cols: 12, rows: 20, blockSize: 0,
            player: { pos: { x: 0, y: 0 }, matrix: null, score: 0 },
            colors: [null, '#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#06b6d4', '#8b5cf6'],
            init() { this.ctx = this.canvas.getContext('2d'); window.addEventListener('keydown', this.handleInput.bind(this)); },
            reset() {
                if (this.canvas.height === 0) return; // Avoid running reset if canvas is not visible
                this.blockSize = this.canvas.height / this.rows;
                this.cols = Math.floor(this.canvas.width / this.blockSize);
                this.grid = this.createMatrix(this.cols, this.rows);
                this.score = 0;
                this.gameOver = false;
                this.paused = true; // Start paused
                this.playerReset();
                this.music.currentTime = 0;
            },
            createMatrix(w, h) { const matrix = []; while (h--) { matrix.push(new Array(w).fill(0)); } return matrix; },
            createPiece(type) { if (type === 'T') return [[0, 0, 0], [1, 1, 1], [0, 1, 0]]; else if (type === 'O') return [[2, 2], [2, 2]]; else if (type === 'L') return [[0, 3, 0], [0, 3, 0], [0, 3, 3]]; else if (type === 'J') return [[0, 4, 0], [0, 4, 0], [4, 4, 0]]; else if (type === 'I') return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]]; else if (type === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]]; else if (type === 'Z') return [[7, 7, 0], [0, 7, 7], [0, 0, 0]]; },
            playerReset() { const pieces = 'TJLOSZI'; this.player.matrix = this.createPiece(pieces[Math.floor(Math.random() * pieces.length)]); this.player.pos.y = 0; this.player.pos.x = (this.cols / 2 | 0) - (this.player.matrix[0].length / 2 | 0); if (this.collide(this.grid, this.player)) { this.gameOver = true; playGameOverSound(); } },
            collide(grid, player) { const [m, o] = [player.matrix, player.pos]; for (let y = 0; y < m.length; ++y) { for (let x = 0; x < m[y].length; ++x) { if (m[y][x] !== 0 && (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0) return true; } } return false; },
            merge(grid, player) { player.matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { grid[y + player.pos.y][x + player.pos.x] = value; } }); }); },
            rotate(matrix, dir) { for (let y = 0; y < matrix.length; ++y) { for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } } if (dir > 0) { matrix.forEach(row => row.reverse()); } else { matrix.reverse(); } },
            playerRotate(dir) { const pos = this.player.pos.x; let offset = 1; this.rotate(this.player.matrix, dir); while (this.collide(this.grid, this.player)) { this.player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1)); if (offset > this.player.matrix[0].length) { this.rotate(this.player.matrix, -dir); this.player.pos.x = pos; return; } } },
            gridSweep() { outer: for (let y = this.grid.length - 1; y > 0; --y) { for (let x = 0; x < this.grid[y].length; ++x) { if (this.grid[y][x] === 0) continue outer; } const row = this.grid.splice(y, 1)[0].fill(0); this.grid.unshift(row); ++y; this.score += 10; } },
            handleInput(e) { if (activeGame !== 'tetris' || this.paused || this.gameOver) return; if (e.key === 'ArrowLeft') this.playerMove(-1); else if (e.key === 'ArrowRight') this.playerMove(1); else if (e.key === 'ArrowDown') this.playerDrop(); else if (e.key === 'ArrowUp') this.playerRotate(1); },
            playerMove(dir) { this.player.pos.x += dir; if (this.collide(this.grid, this.player)) this.player.pos.x -= dir; },
            playerDrop() { this.player.pos.y++; if (this.collide(this.grid, this.player)) { this.player.pos.y--; this.merge(this.grid, this.player); this.playerReset(); this.gridSweep(); } this.dropCounter = 0; },
            update(time = 0) { if (this.gameOver) return; const deltaTime = time - this.lastTime; this.lastTime = time; this.dropCounter += deltaTime; if (this.dropCounter > this.dropInterval) { this.playerDrop(); } },
            drawMatrix(matrix, offset) { matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { this.ctx.fillStyle = this.colors[value]; this.ctx.fillRect((x + offset.x) * this.blockSize, (y + offset.y) * this.blockSize, this.blockSize, this.blockSize); } }); }); },
            draw() {
                this.ctx.fillStyle = '#1e293b'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                if (!this.grid || !this.player.matrix) return; // Guard against drawing before reset
                this.drawMatrix(this.grid, { x: 0, y: 0 }); this.drawMatrix(this.player.matrix, this.player.pos);
                this.ctx.fillStyle = 'white'; this.ctx.font = '16px "Silkscreen"'; this.ctx.fillText(`Score: ${this.score}`, 10, 20);
                if (this.gameOver) { this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'black'; this.ctx.textAlign = 'center'; this.ctx.font = '32px "Silkscreen"'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); }
            },
            gameLoop(time) { if (!this.paused) { this.update(time); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { 
                this.paused = false; 
                this.lastTime = 0;
                this.dropCounter = 0;
                if(this.loop) cancelAnimationFrame(this.loop); 
                this.loop = requestAnimationFrame(this.gameLoop.bind(this)); 
                this.music.play();
            },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; this.music.pause();},
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'hidden' : 'auto'; if (this.gameOver) this.start(); if (this.paused) this.music.pause(); else if (!this.gameOver) this.music.play(); }
        };

        // --- MAIN EVENT LISTENER ---
        document.addEventListener('DOMContentLoaded', () => {
            const gameWindows = document.querySelectorAll('.game-window');
            Object.values(gameInstances).forEach(game => game.init());
            gameWindows.forEach(win => {
                win.addEventListener('click', () => {
                    const gameName = win.dataset.game;
                    const game = gameInstances[gameName];
                    if (gameName === activeGame) {
                        game.togglePause();
                        return;
                    }
                    if (activeGame && gameInstances[activeGame]) {
                        gameInstances[activeGame].stop();
                        document.querySelector(`[data-game="${activeGame}"]`).classList.remove('active');
                    }
                    document.body.style.overflow = 'hidden';
                    activeGame = gameName;
                    win.classList.add('active');
                    
                    // Initialize canvas size before countdown
                    game.canvas.width = game.canvas.offsetWidth;
                    game.canvas.height = game.canvas.offsetHeight;
                    game.reset(); // Reset game state
                    game.draw(); // Draw initial state for countdown background
                    
                    playCountdown(game, () => {
                        game.start();
                    });
                });
            });
        });
    </script>
    <script src="/_vercel/insights/script.js"></script>
</body>
</html>
