<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Optimalizace: Přidán meta description pro SEO -->
    <meta name="description" content="Zahrajte si klasické retro hry jako Snake, Pong, Tetris a další přímo ve vašem prohlížeči. Arkáda plná nostalgické zábavy.">
    <title>Retro Herní Arkáda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&family=Silkscreen&family=Bungee&display=swap" rel="stylesheet">
    <style>
        /* Custom fonts for games */
        body {
            font-family: 'Inter', sans-serif;
            transition: overflow 0.3s ease;
            overflow: auto; /* Ensure scrollbar is visible by default */
        }
        .font-press-start { font-family: 'Press Start 2P', cursive; }
        .font-vt323 { font-family: 'VT323', monospace; }
        .font-silkscreen { font-family: 'Silkscreen', cursive; }
        .font-bungee { font-family: 'Bungee', cursive; }

        /* Game window styles */
        .game-window {
            aspect-ratio: 4 / 3;
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 4px solid #1f2937;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.1);
            position: relative;
            /* Optimalizace: Reset pro <button> element */
            background: none;
            padding: 0;
            text-align: inherit;
        }
        /* Optimalizace: Vizuální zpětná vazba pro interaktivitu */
        .game-window:hover {
            transform: scale(1.03);
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.2), 0 8px 10px -6px rgba(0,0,0,0.1);
            border-color: #4f46e5;
        }
        .game-window.active {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 90vw;
            height: auto;
            max-width: 800px;
            transform: translate(-50%, -50%) scale(1);
            z-index: 50;
            cursor: default;
            border-color: #4f46e5;
        }
        .game-window canvas {
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .game-window.active .game-overlay {
            opacity: 1;
            pointer-events: auto;
        }
        #countdown {
            font-size: 8rem;
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 60;
            pointer-events: none;
            text-shadow: 0 0 15px rgba(255,255,255,0.7);
        }
        /* Tetris next piece canvas */
        #next-piece-canvas {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 80px;
            height: 80px;
            background-color: #0d1117;
            border: 2px solid #30363d;
        }
    </style>
</head>
<body class="bg-gray-900 text-white selection:bg-indigo-500 selection:text-white">

    <!-- Mobile notice -->
    <div class="sm:hidden bg-yellow-500 text-black text-center p-2 font-bold">
        Pro mobilní verzi je web ve výstavbě. Děkuji za trpělivost.
    </div>

    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-12">
            <h1 class="font-bungee text-5xl md:text-7xl font-bold mb-2 text-indigo-400 tracking-wider">Retro Herní Arkáda</h1>
            <p class="font-vt323 text-2xl text-gray-400">Klikni na hru a začni hrát!</p>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
            <!-- Snake -->
            <button data-game="snake" class="game-window bg-gray-800">
                <div class="game-overlay font-silkscreen text-4xl">HADI TANEC</div>
                <canvas id="snake-canvas"></canvas>
            </button>
            <!-- Pong -->
            <button data-game="pong" class="game-window bg-gray-800">
                <div class="game-overlay font-press-start text-4xl">PONG</div>
                <canvas id="pong-canvas"></canvas>
            </button>
            <!-- Breakout -->
            <button data-game="breakout" class="game-window bg-gray-800">
                <div class="game-overlay font-bungee text-4xl">BREAKOUT</div>
                <canvas id="breakout-canvas"></canvas>
            </button>
            <!-- Tetris -->
            <button data-game="tetris" class="game-window bg-gray-800">
                <div class="game-overlay font-press-start text-4xl">TETRIS</div>
                <canvas id="tetris-canvas"></canvas>
                <canvas id="next-piece-canvas" class="hidden"></canvas>
            </button>
            <!-- Space Invaders -->
            <button data-game="invaders" class="game-window bg-gray-800">
                <div class="game-overlay font-vt323 text-5xl">SPACE INVADERS</div>
                <canvas id="invaders-canvas"></canvas>
            </button>
            <!-- Dino Run -->
            <button data-game="dino" class="game-window bg-gray-800">
                <div class="game-overlay font-silkscreen text-4xl">DINO RUN</div>
                <canvas id="dino-canvas"></canvas>
            </button>
        </main>

        <footer class="text-center mt-12 text-gray-500 font-vt323 text-lg">
            <p>&copy; 2025 Gabriel Kozik. Všechna práva vyhrazena.</p>
        </footer>
    </div>

    <!-- Countdown Element -->
    <div id="countdown" class="font-press-start"></div>

    <!-- Audio files -->
    <audio id="snake-music" loop src="hadi-tanec.mp3"></audio>
    <audio id="pong-music" loop src="pong.mp3"></audio>
    <audio id="breakout-music" loop src="breakout.mp3"></audio>
    <audio id="tetris-music" loop src="tetris.mp3"></audio>
    <audio id="invaders-music" loop src="space-invaders.mp3"></audio>
    <audio id="dino-music" loop src="Dino-run.mp3"></audio>
    <audio id="countdown-sound" src="ready-fight.mp3"></audio>
    <audio id="game-over-sound" src="game-over.mp3"></audio>
    <audio id="victory-sound" src="victory.mp3"></audio>

<script>
let activeGame = null;
const gameInstances = {};

// --- UTILITY FUNCTIONS ---
function playCountdown(game, callback) {
    const countdownElement = document.getElementById('countdown');
    const countdownSound = document.getElementById('countdown-sound');
    let count = 3;
    countdownElement.style.display = 'block';
    countdownElement.textContent = count;
    countdownSound.currentTime = 0;
    countdownSound.play();

    const interval = setInterval(() => {
        count--;
        if (count > 0) {
            countdownElement.textContent = count;
        } else {
            clearInterval(interval);
            countdownElement.textContent = 'GO!';
            setTimeout(() => {
                countdownElement.style.display = 'none';
                callback();
            }, 500);
        }
    }, 1000);
}

function playGameOverSound() {
    const sound = document.getElementById('game-over-sound');
    sound.currentTime = 0;
    sound.play();
}

function playVictorySound() {
    const sound = document.getElementById('victory-sound');
    sound.currentTime = 0;
    sound.play();
}


// --- PONG ---
gameInstances.pong = {
    canvas: document.getElementById('pong-canvas'),
    music: document.getElementById('pong-music'),
    ctx: null,
    ball: {},
    player: {},
    computer: {},
    paused: false,
    gameOver: false,
    loop: null,
    winningScore: 5,
    winner: null,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.reset();
        window.addEventListener('mousemove', e => {
            if (activeGame === 'pong' && !this.paused) {
                const rect = this.canvas.getBoundingClientRect();
                this.player.y = e.clientY - rect.top - this.player.height / 2;
            }
        });
    },

    reset() {
        this.ball = { x: this.canvas.width / 2, y: this.canvas.height / 2, radius: 10, speed: 5, dx: 5, dy: 5 };
        this.player = { x: 10, y: this.canvas.height / 2 - 50, width: 10, height: 100, score: 0 };
        this.computer = { x: this.canvas.width - 20, y: this.canvas.height / 2 - 50, width: 10, height: 100, score: 0, speed: 3 };
        this.gameOver = false;
        this.winner = null;
    },

    update() {
        if (this.gameOver) return;

        // Ball movement
        this.ball.x += this.ball.dx;
        this.ball.y += this.ball.dy;

        // Wall collision (top/bottom)
        if (this.ball.y + this.ball.radius > this.canvas.height || this.ball.y - this.ball.radius < 0) {
            this.ball.dy *= -1;
        }

        // Paddle collision
        if (this.ball.x - this.ball.radius < this.player.x + this.player.width &&
            this.ball.y > this.player.y && this.ball.y < this.player.y + this.player.height) {
            this.ball.dx *= -1;
        }
        if (this.ball.x + this.ball.radius > this.computer.x &&
            this.ball.y > this.computer.y && this.ball.y < this.computer.y + this.computer.height) {
            this.ball.dx *= -1;
        }

        // Score
        if (this.ball.x + this.ball.radius < 0) {
            this.computer.score++;
            this.resetBall();
        } else if (this.ball.x - this.ball.radius > this.canvas.width) {
            this.player.score++;
            this.resetBall();
        }

        // Computer AI
        this.computer.y += (this.ball.y - (this.computer.y + this.computer.height / 2)) * 0.05;

        // Check for winner
        if (this.player.score >= this.winningScore) {
            this.gameOver = true;
            this.winner = 'player';
            playVictorySound();
            this.stop();
        } else if (this.computer.score >= this.winningScore) {
            this.gameOver = true;
            this.winner = 'computer';
            playGameOverSound();
            this.stop();
        }
    },

    resetBall() {
        this.ball.x = this.canvas.width / 2;
        this.ball.y = this.canvas.height / 2;
        this.ball.dx *= -1;
    },

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'white';
        
        // Ball
        this.ctx.beginPath();
        this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
        this.ctx.fill();

        // Paddles
        this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
        this.ctx.fillRect(this.computer.x, this.computer.y, this.computer.width, this.computer.height);
        
        // Score
        this.ctx.font = '32px "Press Start 2P"';
        this.ctx.fillText(this.player.score, this.canvas.width / 4, 50);
        this.ctx.fillText(this.computer.score, 3 * this.canvas.width / 4, 50);

        if (this.gameOver) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = 'white';
            this.ctx.textAlign = 'center';
            const message = this.winner === 'player' ? 'VÍTĚZSTVÍ!' : 'GAME OVER';
            this.ctx.fillText(message, this.canvas.width / 2, this.canvas.height / 2);
            this.ctx.font = '16px "Press Start 2P"';
            this.ctx.fillText('Klikni pro restart', this.canvas.width / 2, this.canvas.height / 2 + 40);
        }
    },

    gameLoop() {
        if (!this.paused) {
            this.update();
            this.draw();
        }
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
    },

    start() {
        this.paused = false;
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
        this.music.play();
    },

    stop() {
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = null;
        this.paused = true;
        this.music.pause();
        document.body.style.overflow = 'auto';
    },

    togglePause() {
        this.paused = !this.paused;
        document.body.style.overflow = this.paused ? 'hidden' : 'auto';
        if (this.paused) this.music.pause();
        else if (!this.gameOver) this.music.play();
    }
};

// --- BREAKOUT ---
gameInstances.breakout = {
    canvas: document.getElementById('breakout-canvas'),
    music: document.getElementById('breakout-music'),
    ctx: null,
    ball: {},
    paddle: {},
    bricks: [],
    powerUps: [],
    paused: false,
    gameOver: false,
    loop: null,
    lives: 3,
    score: 0,
    victory: false,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.reset();
        window.addEventListener('mousemove', e => {
            if (activeGame === 'breakout' && !this.paused) {
                const rect = this.canvas.getBoundingClientRect();
                this.paddle.x = e.clientX - rect.left - this.paddle.width / 2;
            }
        });
    },

    reset() {
        this.ball = { x: this.canvas.width / 2, y: this.canvas.height - 50, radius: 8, speed: 4, dx: 4, dy: -4 };
        this.paddle = { x: this.canvas.width / 2 - 50, y: this.canvas.height - 20, width: 100, height: 10 };
        this.lives = 3;
        this.score = 0;
        this.gameOver = false;
        this.victory = false;
        this.powerUps = [];

        this.bricks = [];
        const rows = 7, cols = 10, padding = 2;
        const brickWidth = (this.canvas.width - padding * (cols + 1)) / cols;
        const brickHeight = 20;
        const colors = ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4'];

        for (let c = 0; c < cols; c++) {
            for (let r = 0; r < rows; r++) {
                this.bricks.push({
                    x: padding + c * (brickWidth + padding),
                    y: padding + r * (brickHeight + padding) + 30,
                    width: brickWidth,
                    height: brickHeight,
                    color: colors[r % colors.length],
                    visible: true
                });
            }
        }
    },

    update() {
        if (this.gameOver) return;

        // Ball movement
        this.ball.x += this.ball.dx;
        this.ball.y += this.ball.dy;

        // Wall collision
        if (this.ball.x + this.ball.radius > this.canvas.width || this.ball.x - this.ball.radius < 0) {
            this.ball.dx *= -1;
        }
        if (this.ball.y - this.ball.radius < 0) {
            this.ball.dy *= -1;
        }

        // Paddle collision
        if (this.ball.y + this.ball.radius > this.paddle.y &&
            this.ball.x > this.paddle.x && this.ball.x < this.paddle.x + this.paddle.width) {
            this.ball.dy *= -1;
        }

        // Brick collision
        this.bricks.forEach((brick, index) => {
            if (brick.visible &&
                this.ball.x > brick.x && this.ball.x < brick.x + brick.width &&
                this.ball.y > brick.y && this.ball.y < brick.y + brick.height) {
                brick.visible = false;
                this.ball.dy *= -1;
                this.score += 10;
                // Chance to drop a power-up
                if (Math.random() < 0.2) {
                    this.powerUps.push({x: brick.x + brick.width / 2, y: brick.y, type: 'widen'});
                }
            }
        });
        
        this.bricks = this.bricks.filter(b => b.visible);

        // Power-up movement and collision
        this.powerUps.forEach((pu, index) => {
            pu.y += 2;
            if (pu.y > this.paddle.y && pu.x > this.paddle.x && pu.x < this.paddle.x + this.paddle.width) {
                if (pu.type === 'widen') {
                    this.paddle.width = Math.min(this.paddle.width + 20, 200);
                }
                this.powerUps.splice(index, 1);
            } else if (pu.y > this.canvas.height) {
                 this.powerUps.splice(index, 1);
            }
        });

        // Lose life
        if (this.ball.y + this.ball.radius > this.canvas.height) {
            this.lives--;
            if (this.lives <= 0) {
                this.gameOver = true;
                playGameOverSound();
                this.stop();
            } else {
                this.ball.x = this.canvas.width / 2;
                this.ball.y = this.canvas.height - 50;
                this.ball.dx = 4;
                this.ball.dy = -4;
            }
        }
        
        // Victory condition
        if (this.bricks.length === 0) {
            this.gameOver = true;
            this.victory = true;
            playVictorySound();
            this.stop();
        }
    },

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Ball
        this.ctx.beginPath();
        this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
        this.ctx.fillStyle = 'white';
        this.ctx.fill();
        this.ctx.closePath();

        // Paddle
        this.ctx.fillStyle = '#4f46e5';
        this.ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height);

        // Bricks
        this.bricks.forEach(brick => {
            if (brick.visible) {
                this.ctx.fillStyle = brick.color;
                this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
            }
        });

        // Power-ups
        this.powerUps.forEach(pu => {
            this.ctx.fillStyle = 'cyan';
            this.ctx.fillRect(pu.x - 5, pu.y - 5, 10, 10);
        });

        // UI
        this.ctx.fillStyle = 'white';
        this.ctx.font = '16px "Silkscreen"';
        this.ctx.fillText(`Lives: ${this.lives}`, 10, 20);
        this.ctx.fillText(`Score: ${this.score}`, this.canvas.width - 150, 20);

        if (this.gameOver) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = 'white';
            this.ctx.textAlign = 'center';
            this.ctx.font = '32px "Bungee"';
            const message = this.victory ? 'VÍTĚZSTVÍ!' : 'GAME OVER';
            this.ctx.fillText(message, this.canvas.width / 2, this.canvas.height / 2);
            this.ctx.font = '16px "Bungee"';
            this.ctx.fillText('Klikni pro restart', this.canvas.width / 2, this.canvas.height / 2 + 40);
        }
    },

    gameLoop() {
        if (!this.paused) {
            this.update();
            this.draw();
        }
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
    },

    start() {
        this.paused = false;
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
        this.music.play();
    },

    stop() {
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = null;
        this.paused = true;
        this.music.pause();
        document.body.style.overflow = 'auto';
    },

    togglePause() {
        this.paused = !this.paused;
        document.body.style.overflow = this.paused ? 'hidden' : 'auto';
        if (this.paused) this.music.pause();
        else if (!this.gameOver) this.music.play();
    }
};

// --- DINO RUN ---
gameInstances.dino = {
    canvas: document.getElementById('dino-canvas'),
    music: document.getElementById('dino-music'),
    ctx: null,
    dino: {},
    obstacles: [],
    gameSpeed: 5,
    gravity: 0.6,
    score: 0,
    frameCount: 0,
    paused: false,
    gameOver: false,
    loop: null,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.reset();
        window.addEventListener('keydown', this.handleInput.bind(this));
        window.addEventListener('keyup', this.handleKeyUp.bind(this));
    },

    reset() {
        this.dino = { x: 50, y: this.canvas.height - 50, width: 40, height: 50, dy: 0, jumpPower: 15, grounded: true, isDucking: false, runFrame: 0 };
        this.obstacles = [];
        this.score = 0;
        this.gameSpeed = 5;
        this.frameCount = 0;
        this.gameOver = false;
    },

    handleInput(e) {
        if (activeGame !== 'dino' || this.paused || this.gameOver) return;
        if ((e.code === 'Space' || e.code === 'ArrowUp') && this.dino.grounded) {
            this.dino.dy = -this.dino.jumpPower;
            this.dino.grounded = false;
        }
        if (e.code === 'ArrowDown') {
            this.dino.isDucking = true;
        }
    },
    
    handleKeyUp(e) {
        if (activeGame !== 'dino' && e.code === 'ArrowDown') {
            this.dino.isDucking = false;
        }
    },

    update() {
        if (this.gameOver) return;
        this.frameCount++;

        // Dino physics
        this.dino.dy += this.gravity;
        this.dino.y += this.dino.dy;
        this.dino.grounded = false;
        if (this.dino.y >= this.canvas.height - 50) {
            this.dino.y = this.canvas.height - 50;
            this.dino.dy = 0;
            this.dino.grounded = true;
        }
        
        // Animate Dino
        if (this.dino.grounded && this.frameCount % 5 === 0) {
            this.dino.runFrame = (this.dino.runFrame + 1) % 2;
        }

        // Obstacles
        if (this.frameCount % Math.floor(150 / (this.gameSpeed/5)) === 0) {
            const type = Math.random() > 0.3 ? 'cactus' : 'bird';
            if (type === 'cactus') {
                 const cactusHeight = Math.floor(Math.random() * 30) + 20;
                 this.obstacles.push({ x: this.canvas.width, y: this.canvas.height - cactusHeight, width: 20, height: cactusHeight, type: 'cactus' });
            } else {
                 this.obstacles.push({ x: this.canvas.width, y: this.canvas.height - 70, width: 40, height: 20, type: 'bird', frame: 0 });
            }
        }

        this.obstacles.forEach((obs, i) => {
            obs.x -= this.gameSpeed;
            if (obs.type === 'bird' && this.frameCount % 10 === 0) obs.frame = (obs.frame + 1) % 2;
            if (obs.x + obs.width < 0) this.obstacles.splice(i, 1);

            // Collision detection
            const dinoHeight = this.dino.isDucking ? this.dino.height / 2 : this.dino.height;
            const dinoY = this.dino.isDucking ? this.dino.y + this.dino.height / 2 : this.dino.y;
            
            if (this.dino.x < obs.x + obs.width &&
                this.dino.x + this.dino.width > obs.x &&
                dinoY < obs.y + obs.height &&
                dinoY + dinoHeight > obs.y) {
                this.gameOver = true;
                playGameOverSound();
                this.stop();
            }
        });
        
        this.score++;
        if (this.score % 100 === 0) this.gameSpeed += 0.2;
    },

    drawDino() {
        this.ctx.fillStyle = '#d4d4d8';
        const d = this.dino;
        const dinoY = d.isDucking ? d.y + d.height / 2 : d.y;
        const dinoHeight = d.isDucking ? d.height / 2 : d.height;

        // Body
        this.ctx.fillRect(d.x, dinoY, d.width, dinoHeight);
        // Head
        this.ctx.fillRect(d.x + d.width * 0.7, dinoY, d.width * 0.6, dinoHeight * 0.5);
        // Eye
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(d.x + d.width * 1.1, dinoY + dinoHeight * 0.1, 5, 5);
        
        // Legs (simple animation)
        this.ctx.fillStyle = '#d4d4d8';
        if (d.grounded) {
            if (d.runFrame === 0) {
                this.ctx.fillRect(d.x + 10, dinoY + dinoHeight, 8, 15);
                this.ctx.fillRect(d.x + 25, dinoY + dinoHeight, 8, 10);
            } else {
                this.ctx.fillRect(d.x + 10, dinoY + dinoHeight, 8, 10);
                this.ctx.fillRect(d.x + 25, dinoY + dinoHeight, 8, 15);
            }
        }
    },
    
    drawObstacle(obs) {
        this.ctx.fillStyle = '#84cc16';
        if (obs.type === 'cactus') {
            this.ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            // Cactus arms
            if(obs.height > 25) this.ctx.fillRect(obs.x - 5, obs.y + 5, 5, 10);
            if(obs.height > 35) this.ctx.fillRect(obs.x + obs.width, obs.y + 10, 5, 10);
        } else if (obs.type === 'bird') {
            // Simple bird shape
            this.ctx.fillRect(obs.x, obs.y + 10, obs.width, obs.height * 0.5); // Body
            if (obs.frame === 0) {
                this.ctx.fillRect(obs.x - 10, obs.y, 10, 5); // Upper wing
            } else {
                this.ctx.fillRect(obs.x - 10, obs.y + 15, 10, 5); // Lower wing
            }
        }
    },

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Ground
        this.ctx.fillStyle = '#a1a1aa';
        this.ctx.fillRect(0, this.canvas.height - 20, this.canvas.width, 20);

        this.drawDino();
        this.obstacles.forEach(obs => this.drawObstacle(obs));

        // Score
        this.ctx.fillStyle = 'white';
        this.ctx.font = '20px "Silkscreen"';
        this.ctx.fillText(`Score: ${this.score}`, 10, 30);

        if (this.gameOver) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = 'white';
            this.ctx.textAlign = 'center';
            this.ctx.font = '32px "Silkscreen"';
            this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2);
            this.ctx.font = '16px "Silkscreen"';
            this.ctx.fillText('Klikni pro restart', this.canvas.width / 2, this.canvas.height / 2 + 40);
        }
    },

    gameLoop() {
        if (!this.paused) {
            this.update();
            this.draw();
        }
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
    },

    start() {
        this.paused = false;
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
        this.music.play();
    },

    stop() {
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = null;
        this.paused = true;
        this.music.pause();
        document.body.style.overflow = 'auto';
    },

    togglePause() {
        this.paused = !this.paused;
        document.body.style.overflow = this.paused ? 'hidden' : 'auto';
        if (this.paused) this.music.pause();
        else if (!this.gameOver) this.music.play();
    }
};

// --- TETRIS ---
gameInstances.tetris = {
    canvas: document.getElementById('tetris-canvas'),
    nextCanvas: document.getElementById('next-piece-canvas'),
    music: document.getElementById('tetris-music'),
    ctx: null,
    nextCtx: null,
    grid: null,
    player: { pos: { x: 0, y: 0 }, matrix: null },
    colors: [null, '#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#06b6d4', '#3b82f6'],
    cols: 12,
    rows: 20,
    blockSize: 0,
    dropCounter: 0,
    dropInterval: 1000,
    lastTime: 0,
    score: 0,
    paused: false,
    gameOver: false,
    loop: null,
    nextPiece: null,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.nextCtx = this.nextCanvas.getContext('2d');
        this.blockSize = this.canvas.width / this.cols;
        this.ctx.scale(this.blockSize, this.blockSize);
        this.nextCtx.scale(20, 20); // Scale for the smaller canvas
        this.reset();
        window.addEventListener('keydown', this.handleInput.bind(this));
    },

    reset() {
        this.grid = this.createMatrix(this.cols, this.rows);
        this.nextPiece = this.createPiece('TJLOSZI'[Math.floor(Math.random() * 7)]);
        this.playerReset();
        this.score = 0;
        this.gameOver = false;
    },

    createMatrix(w, h) {
        const matrix = [];
        while (h--) {
            matrix.push(new Array(w).fill(0));
        }
        return matrix;
    },

    createPiece(type) {
        if (type === 'T') return [[0, 0, 0], [1, 1, 1], [0, 1, 0]];
        else if (type === 'J') return [[0, 2, 0], [0, 2, 0], [2, 2, 0]];
        else if (type === 'L') return [[0, 3, 0], [0, 3, 0], [0, 3, 3]];
        else if (type === 'O') return [[4, 4], [4, 4]];
        else if (type === 'I') return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]];
        else if (type === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]];
        else if (type === 'Z') return [[7, 7, 0], [0, 7, 7], [0, 0, 0]];
    },

    playerReset() {
        this.player.matrix = this.nextPiece;
        this.nextPiece = this.createPiece('TJLOSZI'[Math.floor(Math.random() * 7)]);
        this.player.pos.y = 0;
        this.player.pos.x = (this.cols / 2 | 0) - (this.player.matrix[0].length / 2 | 0);
        if (this.collide(this.grid, this.player)) {
            this.gameOver = true;
            playGameOverSound();
            this.stop();
        }
    },

    collide(grid, player) {
        const [m, o] = [player.matrix, player.pos];
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 && (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0) return true;
            }
        }
        return false;
    },

    merge(grid, player) {
        player.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    grid[y + player.pos.y][x + player.pos.x] = value;
                }
            });
        });
    },

    rotate(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        if (dir > 0) {
            matrix.forEach(row => row.reverse());
        } else {
            matrix.reverse();
        }
    },

    playerRotate(dir) {
        const pos = this.player.pos.x;
        let offset = 1;
        this.rotate(this.player.matrix, dir);
        while (this.collide(this.grid, this.player)) {
            this.player.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > this.player.matrix[0].length) {
                this.rotate(this.player.matrix, -dir);
                this.player.pos.x = pos;
                return;
            }
        }
    },

    gridSweep() {
        outer: for (let y = this.grid.length - 1; y > 0; --y) {
            for (let x = 0; x < this.grid[y].length; ++x) {
                if (this.grid[y][x] === 0) continue outer;
            }
            const row = this.grid.splice(y, 1)[0].fill(0);
            this.grid.unshift(row);
            ++y;
            this.score += 10;
        }
    },

    handleInput(e) {
        if (activeGame !== 'tetris' || this.paused || this.gameOver) return;
        if (e.key === 'ArrowLeft') this.playerMove(-1);
        else if (e.key === 'ArrowRight') this.playerMove(1);
        else if (e.key === 'ArrowDown') this.playerDrop();
        else if (e.key === 'ArrowUp') this.playerRotate(1);
    },

    playerMove(dir) {
        this.player.pos.x += dir;
        if (this.collide(this.grid, this.player)) this.player.pos.x -= dir;
    },

    playerDrop() {
        this.player.pos.y++;
        if (this.collide(this.grid, this.player)) {
            this.player.pos.y--;
            this.merge(this.grid, this.player);
            this.playerReset();
            this.gridSweep();
        }
        this.dropCounter = 0;
    },

    update(time = 0) {
        if (this.gameOver) return;
        const deltaTime = time - this.lastTime;
        this.lastTime = time;
        this.dropCounter += deltaTime;
        if (this.dropCounter > this.dropInterval) {
            this.playerDrop();
        }
    },

    drawMatrix(matrix, offset, targetCtx) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    targetCtx.fillStyle = this.colors[value];
                    targetCtx.fillRect(x + offset.x, y + offset.y, 1, 1);
                }
            });
        });
    },

    draw() {
        this.ctx.fillStyle = '#1e293b';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        if (!this.grid || !this.player.matrix) return;
        
        this.drawMatrix(this.grid, { x: 0, y: 0 }, this.ctx);
        this.drawMatrix(this.player.matrix, this.player.pos, this.ctx);
        
        // Draw next piece
        this.nextCtx.fillStyle = '#0d1117';
        this.nextCtx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
        this.drawMatrix(this.nextPiece, {x: 1, y: 1}, this.nextCtx);


        this.ctx.fillStyle = 'white';
        this.ctx.font = '1px "Silkscreen"';
        this.ctx.fillText(`Score: ${this.score}`, 0.5, 1);

        if (this.gameOver) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            this.ctx.fillRect(0, 0, this.cols, this.rows);
            this.ctx.fillStyle = 'black';
            this.ctx.textAlign = 'center';
            this.ctx.font = '2px "Silkscreen"';
            this.ctx.fillText('GAME OVER', this.cols / 2, this.rows / 2);
            this.ctx.font = '1px "Silkscreen"';
            this.ctx.fillText('Klikni pro restart', this.cols / 2, this.rows / 2 + 2);
        }
    },

    gameLoop(time) {
        if (!this.paused) {
            this.update(time);
            this.draw();
        }
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
    },

    start() {
        this.paused = false;
        this.lastTime = 0;
        this.dropCounter = 0;
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = requestAnimationFrame(this.gameLoop.bind(this));
        this.music.play();
        this.nextCanvas.classList.remove('hidden');
    },

    stop() {
        if(this.loop) cancelAnimationFrame(this.loop);
        this.loop = null;
        this.paused = true;
        this.music.pause();
        document.body.style.overflow = 'auto';
        this.nextCanvas.classList.add('hidden');
    },

    togglePause() {
        this.paused = !this.paused;
        document.body.style.overflow = this.paused ? 'hidden' : 'auto';
        if (this.paused) this.music.pause();
        else if (!this.gameOver) this.music.play();
    }
};

// --- MAIN EVENT LISTENER ---
document.addEventListener('DOMContentLoaded', () => {
    const gameWindows = document.querySelectorAll('.game-window');
    Object.values(gameInstances).forEach(game => game.init());

    gameWindows.forEach(win => {
        win.addEventListener('click', () => {
            const gameName = win.dataset.game;
            const game = gameInstances[gameName];

            if (gameName === activeGame) {
                if (!game.gameOver) {
                    game.togglePause();
                } else {
                    // Restart logic
                    if (activeGame && gameInstances[activeGame]) {
                        gameInstances[activeGame].stop();
                    }
                    game.reset();
                    playCountdown(game, () => {
                        game.start();
                    });
                }
                return;
            }

            if (activeGame && gameInstances[activeGame]) {
                gameInstances[activeGame].stop();
                document.querySelector(`[data-game="${activeGame}"]`).classList.remove('active');
            }

            document.body.style.overflow = 'hidden';
            activeGame = gameName;
            win.classList.add('active');
            
            game.canvas.width = game.canvas.offsetWidth;
            game.canvas.height = game.canvas.offsetHeight;
            game.reset();
            game.draw();
            
            playCountdown(game, () => {
                game.start();
            });
        });
    });
});
</script>
</body>
</html>
