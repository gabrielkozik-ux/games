<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Herní Arkáda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&family=Silkscreen&family=Bungee&display=swap" rel="stylesheet">
    <style>
        /* Custom fonts for games */
        body {
            font-family: 'Inter', sans-serif;
            transition: overflow 0.3s ease;
            overflow: auto; /* Ensure scrollbar is visible by default */
        }
        .font-press-start { font-family: 'Press Start 2P', cursive; }
        .font-vt323 { font-family: 'VT323', monospace; }
        .font-silkscreen { font-family: 'Silkscreen', cursive; }
        .font-bungee { font-family: 'Bungee', cursive; }

        /* Game window styles */
        .game-window {
            aspect-ratio: 4 / 3;
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 4px solid #1f2937;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.1);
        }
        .game-window h2 {
            transition: opacity 0.3s ease;
        }
        .game-window canvas {
            display: none; /* Canvases are hidden by default */
            width: 100%;
            height: 100%;
        }
        .game-window.active h2 {
            display: none;
        }
        .game-window.active canvas {
            display: block;
        }
        
        /* Thematic backgrounds */
        #snake-window { background-color: #a3e635; }
        #pong-window { background-color: #60a5fa; }
        #breakout-window { background-color: #facc15; }
        #dino-window { background-color: #d1d5db; }
        #invaders-window { background-color: #4c1d95; } /* Deep purple */
        #tetris-window { background-color: #fca5a5; } /* Light red */


        /* Prevent text selection */
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="bg-gray-800 text-white p-4 sm:p-8 flex flex-col min-h-screen noselect">
    <header class="text-center mb-4 sm:mb-8">
        <h1 class="text-4xl md:text-6xl font-bungee tracking-wider">Retro Herní Arkáda</h1>
        <p class="text-gray-400 mt-2 font-vt323 text-xl">Klikni na hru pro spuštění / pauzu</p>
        <p class="text-gray-500 mt-4 font-vt323 text-lg">Příjemnou zábavu ti přeje Gabriel</p>
    </header>

    <main class="flex-grow grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-8">
        <!-- Snake Game -->
        <div id="snake-window" class="game-window" data-game="snake">
            <h2 class="text-4xl md:text-5xl font-press-start text-gray-900">SNAKE</h2>
            <canvas id="snake-canvas"></canvas>
        </div>

        <!-- Pong Game -->
        <div id="pong-window" class="game-window" data-game="pong">
            <h2 class="text-4xl md:text-5xl font-silkscreen text-gray-900">PONG</h2>
            <canvas id="pong-canvas"></canvas>
        </div>

        <!-- Breakout Game -->
        <div id="breakout-window" class="game-window" data-game="breakout">
            <h2 class="text-4xl md:text-5xl font-bungee text-gray-900">BREAKOUT</h2>
            <canvas id="breakout-canvas"></canvas>
        </div>
        
        <!-- Dino Run Game -->
        <div id="dino-window" class="game-window" data-game="dino">
            <h2 class="text-4xl md:text-5xl font-vt323 text-gray-900">DINO RUN</h2>
            <canvas id="dino-canvas"></canvas>
        </div>

        <!-- Space Invaders Game -->
        <div id="invaders-window" class="game-window" data-game="invaders">
            <h2 class="text-4xl md:text-5xl font-press-start text-white">SPACE INVADERS</h2>
            <canvas id="invaders-canvas"></canvas>
        </div>

        <!-- Tetris Game -->
        <div id="tetris-window" class="game-window" data-game="tetris">
            <h2 class="text-4xl md:text-5xl font-silkscreen text-gray-900">TETRIS</h2>
            <canvas id="tetris-canvas"></canvas>
        </div>
    </main>

    <footer class="mt-8 pt-6 border-t border-gray-700 text-center">
        <div class="flex flex-col md:flex-row items-center justify-center gap-6">
            <div class="text-left">
                <h3 class="font-bungee text-2xl text-yellow-400">Líbí se ti hry?</h3>
                <p class="text-gray-400 font-vt323 text-lg">Můžeš mi poděkovat koupí lahodné kávy.</p>
                <a href="https://buymeacoffee.com/gaboslovak" target="_blank" class="mt-2 inline-block bg-yellow-400 text-gray-900 font-bold py-2 px-4 rounded-lg hover:bg-yellow-300 transition-colors font-sans">
                    buymeacoffee.com/gaboslovak
                </a>
            </div>
            <div>
                <img src="bmc_qr.png" alt="QR kód pro Buy Me a Coffee" class="w-32 h-32 rounded-lg border-4 border-gray-600">
            </div>
        </div>
    </footer>

    <script>
        // --- GLOBAL GAME CONTROLLER ---
        let activeGame = null;
        const gameInstances = {};
        const keysPressed = {};

        // --- GLOBAL KEY LISTENERS ---
        window.addEventListener('keydown', (e) => { keysPressed[e.key] = true; });
        window.addEventListener('keyup', (e) => { keysPressed[e.key] = false; });


        // --- GAME IMPLEMENTATIONS ---

        // --- SNAKE ---
        gameInstances.snake = {
            canvas: document.getElementById('snake-canvas'),
            ctx: null, tileSize: 20, snake: [], food: {}, direction: 'right', newDirection: 'right', score: 0, gameOver: false, paused: false, loop: null, lastUpdateTime: 0, updateInterval: 120,
            init() { this.ctx = this.canvas.getContext('2d'); this.reset(); window.addEventListener('keydown', this.handleInput.bind(this)); },
            reset() { this.snake = [{ x: 10, y: 10 }]; this.direction = 'right'; this.newDirection = 'right'; this.score = 0; this.gameOver = false; if(this.canvas.width > 0) this.placeFood(); },
            placeFood() { const c = Math.floor(this.canvas.width / this.tileSize), r = Math.floor(this.canvas.height / this.tileSize); this.food = { x: Math.floor(Math.random() * c), y: Math.floor(Math.random() * r) }; },
            handleInput(e) { if (activeGame !== 'snake' || this.paused) return; if (e.key === 'ArrowUp' && this.direction !== 'down') this.newDirection = 'up'; else if (e.key === 'ArrowDown' && this.direction !== 'up') this.newDirection = 'down'; else if (e.key === 'ArrowLeft' && this.direction !== 'right') this.newDirection = 'left'; else if (e.key === 'ArrowRight' && this.direction !== 'left') this.newDirection = 'right'; },
            update() { if (this.gameOver) return; this.direction = this.newDirection; const head = { ...this.snake[0] }; if (this.direction === 'right') head.x++; if (this.direction === 'left') head.x--; if (this.direction === 'up') head.y--; if (this.direction === 'down') head.y++; const c = Math.floor(this.canvas.width / this.tileSize), r = Math.floor(this.canvas.height / this.tileSize); if (head.x < 0 || head.x >= c || head.y < 0 || head.y >= r) { this.gameOver = true; document.body.style.overflow = 'auto'; return; } for (let i = 1; i < this.snake.length; i++) { if (head.x === this.snake[i].x && head.y === this.snake[i].y) { this.gameOver = true; document.body.style.overflow = 'auto'; return; } } this.snake.unshift(head); if (head.x === this.food.x && head.y === this.food.y) { this.score++; this.placeFood(); } else { this.snake.pop(); } },
            draw() { this.ctx.fillStyle = '#1a2e05'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#84cc16'; this.snake.forEach(seg => { this.ctx.fillRect(seg.x * this.tileSize, seg.y * this.tileSize, this.tileSize - 1, this.tileSize - 1); }); this.ctx.fillStyle = '#ef4444'; this.ctx.fillRect(this.food.x * this.tileSize, this.food.y * this.tileSize, this.tileSize, this.tileSize); this.ctx.fillStyle = 'white'; this.ctx.font = `${this.tileSize * 1.5}px "Press Start 2P"`; this.ctx.fillText(`Score: ${this.score}`, this.tileSize, this.tileSize * 2); if (this.gameOver) { this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); } },
            gameLoop(time) { if (!this.paused) { if (time - this.lastUpdateTime > this.updateInterval) { this.update(); this.lastUpdateTime = time; } this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.canvas.width = this.canvas.offsetWidth; this.canvas.height = this.canvas.offsetHeight; this.tileSize = Math.floor(this.canvas.width / 25); this.reset(); this.paused = false; this.lastUpdateTime = 0; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; },
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'auto' : 'hidden'; if (this.gameOver) this.start(); }
        };

        // --- PONG ---
        gameInstances.pong = {
            canvas: document.getElementById('pong-canvas'),
            ctx: null, ball: {}, player: {}, ai: {}, paused: false, loop: null,
            init() { this.ctx = this.canvas.getContext('2d'); this.reset(); },
            reset() { this.paddleWidth = 10; this.paddleHeight = this.canvas.height / 5; this.ballSize = 10; this.ball = { x: this.canvas.width / 2, y: this.canvas.height / 2, dx: 5, dy: 5, size: this.ballSize }; this.player = { x: 20, y: this.canvas.height / 2 - this.paddleHeight / 2, width: this.paddleWidth, height: this.paddleHeight, score: 0, speed: 6 }; this.ai = { x: this.canvas.width - 30, y: this.canvas.height / 2 - this.paddleHeight / 2, width: this.paddleWidth, height: this.paddleHeight, score: 0, speed: 4 }; },
            update() { if (this.paused) return; if (keysPressed['ArrowUp']) this.player.y -= this.player.speed; if (keysPressed['ArrowDown']) this.player.y += this.player.speed; if (this.player.y < 0) this.player.y = 0; if (this.player.y + this.player.height > this.canvas.height) this.player.y = this.canvas.height - this.player.height; this.ball.x += this.ball.dx; this.ball.y += this.ball.dy; if (this.ball.y + this.ball.size > this.canvas.height || this.ball.y - this.ball.size < 0) this.ball.dy *= -1; if (this.ball.x - this.ball.size < this.player.x + this.player.width && this.ball.x > this.player.x && this.ball.y > this.player.y && this.ball.y < this.player.y + this.player.height) this.ball.dx *= -1.1; if (this.ball.x + this.ball.size > this.ai.x && this.ball.x < this.ai.x + this.ai.width && this.ball.y > this.ai.y && this.ball.y < this.ai.y + this.ai.height) this.ball.dx *= -1.1; if (this.ball.x + this.ball.size < 0) { this.ai.score++; this.resetBall(); } if (this.ball.x - this.ball.size > this.canvas.width) { this.player.score++; this.resetBall(); } const aiCenter = this.ai.y + this.ai.height / 2; if (aiCenter < this.ball.y - 35) this.ai.y += this.ai.speed; else if (aiCenter > this.ball.y + 35) this.ai.y -= this.ai.speed; if (this.ai.y < 0) this.ai.y = 0; if (this.ai.y + this.ai.height > this.canvas.height) this.ai.y = this.canvas.height - this.ai.height; },
            resetBall() { this.ball.x = this.canvas.width / 2; this.ball.y = this.canvas.height / 2; this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 5; this.ball.dy = (Math.random() > 0.5 ? 1 : -1) * 5; },
            draw() { this.ctx.fillStyle = '#0f172a'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; this.ctx.lineWidth = 4; this.ctx.setLineDash([10, 10]); this.ctx.beginPath(); this.ctx.moveTo(this.canvas.width / 2, 0); this.ctx.lineTo(this.canvas.width / 2, this.canvas.height); this.ctx.stroke(); this.ctx.setLineDash([]); this.ctx.fillStyle = 'white'; this.ctx.beginPath(); this.ctx.arc(this.ball.x, this.ball.y, this.ball.size, 0, Math.PI * 2); this.ctx.fill(); this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height); this.ctx.fillRect(this.ai.x, this.ai.y, this.ai.width, this.ai.height); this.ctx.font = `${this.canvas.width / 10}px "Silkscreen"`; this.ctx.textAlign = 'center'; this.ctx.fillText(this.player.score, this.canvas.width / 4, this.canvas.height / 5); this.ctx.fillText(this.ai.score, this.canvas.width * 3 / 4, this.canvas.height / 5); },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.canvas.width = this.canvas.offsetWidth; this.canvas.height = this.canvas.offsetHeight; this.reset(); this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; },
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'auto' : 'hidden'; }
        };

        // --- BREAKOUT (ENHANCED) ---
        gameInstances.breakout = {
            canvas: document.getElementById('breakout-canvas'), ctx: null, balls: [], paddle: {}, bricks: [], powerUps: [], brickRowCount: 8, brickColumnCount: 12, paused: false, gameOver: false, loop: null,
            init() { this.ctx = this.canvas.getContext('2d'); this.reset(); },
            reset() { this.balls = [{ x: this.canvas.width / 2, y: this.canvas.height - 50, dx: 3, dy: -3, radius: 7 }]; this.paddle = { x: this.canvas.width / 2 - 50, y: this.canvas.height - 20, width: 100, height: 10, speed: 8 }; this.powerUps = []; this.createBricks(); this.gameOver = false; },
            createBricks() { this.bricks = []; const brickWidth = this.canvas.width / (this.brickColumnCount + 2); const brickHeight = 15; const brickPadding = 4; const brickOffsetTop = 30; const brickOffsetLeft = (this.canvas.width - (this.brickColumnCount * (brickWidth + brickPadding))) / 2; const colors = ['#dc2626', '#f97316', '#f59e0b', '#84cc16', '#22c55e', '#06b6d4', '#6366f1', '#a855f7']; for (let c = 0; c < this.brickColumnCount; c++) { this.bricks[c] = []; for (let r = 0; r < this.brickRowCount; r++) { this.bricks[c][r] = { x: c * (brickWidth + brickPadding) + brickOffsetLeft, y: r * (brickHeight + brickPadding) + brickOffsetTop, width: brickWidth, height: brickHeight, status: 1, color: colors[r % colors.length] }; } } },
            spawnPowerUp(x, y) { if (Math.random() < 0.2) { const types = ['multi-ball', 'fast-ball', 'slow-ball']; const type = types[Math.floor(Math.random() * types.length)]; this.powerUps.push({ x, y, type, width: 15, height: 15, dy: 2 }); } },
            activatePowerUp(type) { if (type === 'multi-ball') { this.balls.push({ ...this.balls[0], dx: -this.balls[0].dx }); } else if (type === 'fast-ball') { this.balls.forEach(b => { b.dx *= 1.3; b.dy *= 1.3; }); } else if (type === 'slow-ball') { this.balls.forEach(b => { b.dx *= 0.7; b.dy *= 0.7; }); } },
            collisionDetection() { for (let ball of this.balls) { for (let c = 0; c < this.brickColumnCount; c++) { for (let r = 0; r < this.brickRowCount; r++) { const b = this.bricks[c][r]; if (b.status === 1) { if (ball.x > b.x && ball.x < b.x + b.width && ball.y > b.y && ball.y < b.y + b.height) { ball.dy = -ball.dy; b.status = 0; this.spawnPowerUp(b.x + b.width / 2, b.y + b.height / 2); } } } } } },
            update() { if (this.paused || this.gameOver) return; if (keysPressed['ArrowLeft']) this.paddle.x -= this.paddle.speed; if (keysPressed['ArrowRight']) this.paddle.x += this.paddle.speed; if (this.paddle.x < 0) this.paddle.x = 0; if (this.paddle.x + this.paddle.width > this.canvas.width) this.paddle.x = this.canvas.width - this.paddle.width; for (let i = this.balls.length - 1; i >= 0; i--) { let ball = this.balls[i]; ball.x += ball.dx; ball.y += ball.dy; if (ball.x + ball.radius > this.canvas.width || ball.x - ball.radius < 0) ball.dx = -ball.dx; if (ball.y - ball.radius < 0) ball.dy = -ball.dy; else if (ball.y + ball.radius > this.paddle.y && ball.y - ball.radius < this.paddle.y + this.paddle.height && ball.x > this.paddle.x && ball.x < this.paddle.x + this.paddle.width) { ball.dy = -ball.dy; } else if (ball.y + ball.radius > this.canvas.height) { this.balls.splice(i, 1); } } if (this.balls.length === 0) { this.gameOver = true; document.body.style.overflow = 'auto'; } for (let i = this.powerUps.length - 1; i >= 0; i--) { let p = this.powerUps[i]; p.y += p.dy; if (p.y > this.paddle.y && p.y < this.paddle.y + this.paddle.height && p.x > this.paddle.x && p.x < this.paddle.x + this.paddle.width) { this.activatePowerUp(p.type); this.powerUps.splice(i, 1); } else if (p.y > this.canvas.height) { this.powerUps.splice(i, 1); } } this.collisionDetection(); },
            draw() { this.ctx.fillStyle = '#1e293b'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.bricks.forEach(col => col.forEach(b => { if (b.status === 1) { this.ctx.fillStyle = b.color; this.ctx.fillRect(b.x, b.y, b.width, b.height); } })); this.balls.forEach(ball => { this.ctx.beginPath(); this.ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); this.ctx.fillStyle = '#fff'; this.ctx.fill(); this.ctx.closePath(); }); this.powerUps.forEach(p => { this.ctx.fillStyle = p.type === 'multi-ball' ? '#34d399' : p.type === 'fast-ball' ? '#ef4444' : '#60a5fa'; this.ctx.fillRect(p.x, p.y, p.width, p.height); }); this.ctx.fillStyle = '#94a3b8'; this.ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height); if (this.gameOver) { this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'white'; this.ctx.font = '32px "Bungee"'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); } },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.canvas.width = this.canvas.offsetWidth; this.canvas.height = this.canvas.offsetHeight; this.reset(); this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; },
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'auto' : 'hidden'; if (this.gameOver) this.start(); }
        };

        // --- DINO RUN (ENHANCED) ---
        gameInstances.dino = {
            canvas: document.getElementById('dino-canvas'), ctx: null, dino: {}, obstacles: [], gravity: 0.8, gameSpeed: 5, score: 0, frameCount: 0, paused: false, gameOver: false, loop: null,
            init() { this.ctx = this.canvas.getContext('2d'); this.reset(); window.addEventListener('keydown', this.handleInput.bind(this)); window.addEventListener('keyup', this.handleKeyUp.bind(this)); },
            reset() { this.dino = { x: 50, y: 0, width: 44, height: 47, dy: 0, jumpPower: 15, grounded: true, isDucking: false, runFrame: 0 }; this.obstacles = []; this.score = 0; this.gameSpeed = 5; this.gameOver = false; this.frameCount = 0; },
            handleInput(e) { if (activeGame !== 'dino' || this.paused) return; if ((e.key === ' ' || e.key === 'ArrowUp') && this.dino.grounded) { this.dino.dy = -this.dino.jumpPower; this.dino.grounded = false; } else if (e.key === 'ArrowDown') { this.dino.isDucking = true; } },
            handleKeyUp(e) { if (activeGame !== 'dino' || this.paused) return; if (e.key === 'ArrowDown') { this.dino.isDucking = false; } },
            update() { if (this.paused || this.gameOver) return; this.frameCount++; this.score++; this.dino.dy += this.gravity; this.dino.y += this.dino.dy; const groundY = this.canvas.height - 20; if (this.dino.y + this.dino.height > groundY) { this.dino.y = groundY - this.dino.height; this.dino.dy = 0; this.dino.grounded = true; } if (this.dino.isDucking) { this.dino.height = 25; } else { this.dino.height = 47; } if (this.frameCount % 5 === 0) { this.dino.runFrame = (this.dino.runFrame + 1) % 2; } if (this.frameCount % Math.max(90 - Math.floor(this.gameSpeed), 50) === 0) { const type = Math.random() > 0.3 ? 'cactus' : 'bird'; if (type === 'cactus') { const cactusType = Math.floor(Math.random() * 3); this.obstacles.push({ type: 'cactus', cactusType: cactusType, x: this.canvas.width, y: groundY - [35, 50, 25][cactusType], width: [20, 40, 60][cactusType], height: [35, 50, 25][cactusType] }); } else { this.obstacles.push({ type: 'bird', x: this.canvas.width, y: groundY - 60 - (Math.random() * 40), width: 40, height: 30, frame: 0 }); } } for (let i = this.obstacles.length - 1; i >= 0; i--) { const obs = this.obstacles[i]; obs.x -= this.gameSpeed; if (obs.type === 'bird' && this.frameCount % 10 === 0) { obs.frame = (obs.frame + 1) % 2; } const dinoHitbox = { x: this.dino.x, y: this.dino.y, width: this.dino.width, height: this.dino.height }; if (dinoHitbox.x < obs.x + obs.width && dinoHitbox.x + dinoHitbox.width > obs.x && dinoHitbox.y < obs.y + obs.height && dinoHitbox.y + dinoHitbox.height > obs.y) { this.gameOver = true; document.body.style.overflow = 'auto'; } if (obs.x + obs.width < 0) this.obstacles.splice(i, 1); } this.gameSpeed += 0.003; },
            drawDino() { const c = this.ctx; const d = this.dino; c.fillStyle = '#4b5563'; if (!this.dino.grounded) { c.fillRect(d.x, d.y, d.width, d.height); } else if (this.dino.isDucking) { c.fillRect(d.x, d.y, 58, d.height); } else { if (d.runFrame === 0) { c.fillRect(d.x, d.y, d.width, d.height); } else { c.fillRect(d.x, d.y, d.width, d.height); } } },
            drawCactus(obs) { this.ctx.fillStyle = '#166534'; this.ctx.fillRect(obs.x, obs.y, obs.width, obs.height); },
            drawBird(obs) { this.ctx.fillStyle = '#374151'; if (obs.frame === 0) { this.ctx.fillRect(obs.x, obs.y + 10, obs.width, 10); this.ctx.fillRect(obs.x + 10, obs.y, 20, obs.height); } else { this.ctx.fillRect(obs.x, obs.y, obs.width, 10); this.ctx.fillRect(obs.x + 10, obs.y + 10, 20, obs.height - 10); } },
            draw() { this.ctx.fillStyle = '#f3f4f6'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#4b5563'; this.ctx.fillRect(0, this.canvas.height - 20, this.canvas.width, 20); this.drawDino(); this.obstacles.forEach(obs => { if (obs.type === 'cactus') this.drawCactus(obs); else this.drawBird(obs); }); this.ctx.fillStyle = '#4b5563'; this.ctx.font = '24px "VT323"'; this.ctx.textAlign = 'right'; this.ctx.fillText(`SCORE: ${Math.floor(this.score/5)}`, this.canvas.width - 20, 30); if (this.gameOver) { this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#f3f4f6'; this.ctx.font = '32px "VT323"'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); } },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.canvas.width = this.canvas.offsetWidth; this.canvas.height = this.canvas.offsetHeight; this.reset(); this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; },
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'auto' : 'hidden'; if (this.gameOver) this.start(); }
        };

        // --- SPACE INVADERS ---
        gameInstances.invaders = {
            canvas: document.getElementById('invaders-canvas'), ctx: null, player: {}, bullets: [], invaders: [], invaderBullets: [], invaderDirection: 1, invaderSpeed: 0.5, score: 0, paused: false, gameOver: false, loop: null, lastShotTime: 0, shootCooldown: 300,
            init() { this.ctx = this.canvas.getContext('2d'); this.reset(); window.addEventListener('keydown', this.handleInput.bind(this)); },
            reset() { this.player = { x: this.canvas.width / 2 - 25, y: this.canvas.height - 40, width: 50, height: 20, speed: 5 }; this.bullets = []; this.invaderBullets = []; this.createInvaders(); this.score = 0; this.gameOver = false; },
            createInvaders() { this.invaders = []; const rows = 5, cols = 10; for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { this.invaders.push({ x: c * 40 + 40, y: r * 30 + 30, width: 30, height: 20 }); } } },
            handleInput(e) { if (activeGame !== 'invaders' || this.paused) return; if (e.key === ' ' && Date.now() - this.lastShotTime > this.shootCooldown) { this.bullets.push({ x: this.player.x + this.player.width / 2 - 2.5, y: this.player.y, width: 5, height: 10, dy: -7 }); this.lastShotTime = Date.now(); } },
            update() { if (this.paused || this.gameOver) return; if (keysPressed['ArrowLeft'] && this.player.x > 0) this.player.x -= this.player.speed; if (keysPressed['ArrowRight'] && this.player.x + this.player.width < this.canvas.width) this.player.x += this.player.speed; this.bullets.forEach((b, i) => { b.y += b.dy; if (b.y < 0) this.bullets.splice(i, 1); }); this.invaderBullets.forEach((b, i) => { b.y += b.dy; if (b.y > this.canvas.height) this.invaderBullets.splice(i, 1); if(b.x > this.player.x && b.x < this.player.x+this.player.width && b.y > this.player.y && b.y < this.player.y + this.player.height) { this.gameOver = true; document.body.style.overflow = 'auto'; } }); let edgeReached = false; this.invaders.forEach(inv => { inv.x += this.invaderSpeed * this.invaderDirection; if (inv.x <= 0 || inv.x + inv.width >= this.canvas.width) edgeReached = true; if (inv.y + inv.height > this.player.y) { this.gameOver = true; document.body.style.overflow = 'auto'; } }); if (edgeReached) { this.invaderDirection *= -1; this.invaders.forEach(inv => inv.y += 10); } if (Math.random() < 0.01 && this.invaders.length > 0) { const shooter = this.invaders[Math.floor(Math.random() * this.invaders.length)]; this.invaderBullets.push({ x: shooter.x + shooter.width / 2, y: shooter.y + shooter.height, width: 5, height: 10, dy: 5 }); } for (let i = this.bullets.length - 1; i >= 0; i--) { for (let j = this.invaders.length - 1; j >= 0; j--) { if (this.bullets[i] && this.invaders[j] && this.bullets[i].x < this.invaders[j].x + this.invaders[j].width && this.bullets[i].x + this.bullets[i].width > this.invaders[j].x && this.bullets[i].y < this.invaders[j].y + this.invaders[j].height && this.bullets[i].y + this.bullets[i].height > this.invaders[j].y) { this.bullets.splice(i, 1); this.invaders.splice(j, 1); this.score += 10; } } } },
            draw() { this.ctx.fillStyle = '#000'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height); this.bullets.forEach(b => this.ctx.fillRect(b.x, b.y, b.width, b.height)); this.ctx.fillStyle = '#f00'; this.invaderBullets.forEach(b => this.ctx.fillRect(b.x, b.y, b.width, b.height)); this.ctx.fillStyle = '#fff'; this.invaders.forEach(inv => this.ctx.fillRect(inv.x, inv.y, inv.width, inv.height)); this.ctx.fillStyle = '#fff'; this.ctx.font = '20px "Press Start 2P"'; this.ctx.fillText(`Score: ${this.score}`, 10, 25); if (this.gameOver) { this.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); } },
            gameLoop() { if (!this.paused) { this.update(); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.canvas.width = this.canvas.offsetWidth; this.canvas.height = this.canvas.offsetHeight; this.reset(); this.paused = false; if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; },
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'auto' : 'hidden'; if (this.gameOver) this.start(); }
        };

        // --- TETRIS ---
        gameInstances.tetris = {
            canvas: document.getElementById('tetris-canvas'), ctx: null, grid: [], score: 0, gameOver: false, paused: false, loop: null, dropCounter: 0, dropInterval: 1000, lastTime: 0,
            cols: 12, rows: 20, blockSize: 0,
            player: { pos: { x: 0, y: 0 }, matrix: null, score: 0 },
            colors: [null, '#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#06b6d4', '#8b5cf6'],
            init() { this.ctx = this.canvas.getContext('2d'); window.addEventListener('keydown', this.handleInput.bind(this)); },
            createMatrix(w, h) { const matrix = []; while (h--) { matrix.push(new Array(w).fill(0)); } return matrix; },
            createPiece(type) { if (type === 'T') return [[0, 0, 0], [1, 1, 1], [0, 1, 0]]; else if (type === 'O') return [[2, 2], [2, 2]]; else if (type === 'L') return [[0, 3, 0], [0, 3, 0], [0, 3, 3]]; else if (type === 'J') return [[0, 4, 0], [0, 4, 0], [4, 4, 0]]; else if (type === 'I') return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]]; else if (type === 'S') return [[0, 6, 6], [6, 6, 0], [0, 0, 0]]; else if (type === 'Z') return [[7, 7, 0], [0, 7, 7], [0, 0, 0]]; },
            playerReset() { const pieces = 'TJLOSZI'; this.player.matrix = this.createPiece(pieces[Math.floor(Math.random() * pieces.length)]); this.player.pos.y = 0; this.player.pos.x = (this.cols / 2 | 0) - (this.player.matrix[0].length / 2 | 0); if (this.collide(this.grid, this.player)) { this.gameOver = true; document.body.style.overflow = 'auto'; } },
            collide(grid, player) { const [m, o] = [player.matrix, player.pos]; for (let y = 0; y < m.length; ++y) { for (let x = 0; x < m[y].length; ++x) { if (m[y][x] !== 0 && (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0) return true; } } return false; },
            merge(grid, player) { player.matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { grid[y + player.pos.y][x + player.pos.x] = value; } }); }); },
            rotate(matrix, dir) { for (let y = 0; y < matrix.length; ++y) { for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } } if (dir > 0) { matrix.forEach(row => row.reverse()); } else { matrix.reverse(); } },
            playerRotate(dir) { const pos = this.player.pos.x; let offset = 1; this.rotate(this.player.matrix, dir); while (this.collide(this.grid, this.player)) { this.player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1)); if (offset > this.player.matrix[0].length) { this.rotate(this.player.matrix, -dir); this.player.pos.x = pos; return; } } },
            gridSweep() { outer: for (let y = this.grid.length - 1; y > 0; --y) { for (let x = 0; x < this.grid[y].length; ++x) { if (this.grid[y][x] === 0) continue outer; } const row = this.grid.splice(y, 1)[0].fill(0); this.grid.unshift(row); ++y; this.score += 10; } },
            handleInput(e) { if (activeGame !== 'tetris' || this.paused || this.gameOver) return; if (e.key === 'ArrowLeft') this.playerMove(-1); else if (e.key === 'ArrowRight') this.playerMove(1); else if (e.key === 'ArrowDown') this.playerDrop(); else if (e.key === 'ArrowUp') this.playerRotate(1); },
            playerMove(dir) { this.player.pos.x += dir; if (this.collide(this.grid, this.player)) this.player.pos.x -= dir; },
            playerDrop() { this.player.pos.y++; if (this.collide(this.grid, this.player)) { this.player.pos.y--; this.merge(this.grid, this.player); this.playerReset(); this.gridSweep(); } this.dropCounter = 0; },
            update(time = 0) { if (this.paused || this.gameOver) return; const deltaTime = time - this.lastTime; this.lastTime = time; this.dropCounter += deltaTime; if (this.dropCounter > this.dropInterval) { this.playerDrop(); } },
            drawMatrix(matrix, offset) { matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { this.ctx.fillStyle = this.colors[value]; this.ctx.fillRect(x + offset.x, y + offset.y, 1, 1); } }); }); },
            draw() { this.ctx.fillStyle = '#000'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.save(); this.ctx.scale(this.blockSize, this.blockSize); this.drawMatrix(this.grid, { x: 0, y: 0 }); this.drawMatrix(this.player.matrix, this.player.pos); this.ctx.restore(); this.ctx.fillStyle = 'white'; this.ctx.font = '16px "Silkscreen"'; this.ctx.fillText(`Score: ${this.score}`, 10, 20); if (this.gameOver) { this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = 'black'; this.ctx.textAlign = 'center'; this.ctx.font = '32px "Silkscreen"'; this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2); } },
            gameLoop(time) { if (!this.paused) { this.update(time); this.draw(); } this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            start() { this.canvas.width = this.canvas.offsetWidth; this.canvas.height = this.canvas.offsetHeight; this.blockSize = this.canvas.height / this.rows; this.cols = Math.floor(this.canvas.width / this.blockSize); this.grid = this.createMatrix(this.cols, this.rows); this.score = 0; this.gameOver = false; this.paused = false; this.playerReset(); if(this.loop) cancelAnimationFrame(this.loop); this.loop = requestAnimationFrame(this.gameLoop.bind(this)); },
            stop() { if(this.loop) cancelAnimationFrame(this.loop); this.loop = null; this.paused = true; },
            togglePause() { this.paused = !this.paused; document.body.style.overflow = this.paused ? 'auto' : 'hidden'; if (this.gameOver) this.start(); }
        };

        // --- MAIN EVENT LISTENER ---
        document.addEventListener('DOMContentLoaded', () => {
            const gameWindows = document.querySelectorAll('.game-window');

            Object.values(gameInstances).forEach(game => game.init());

            gameWindows.forEach(win => {
                win.addEventListener('click', () => {
                    const gameName = win.dataset.game;
                    const game = gameInstances[gameName];

                    if (gameName === activeGame) {
                        game.togglePause();
                        return;
                    }

                    if (activeGame && gameInstances[activeGame]) {
                        gameInstances[activeGame].stop();
                        document.querySelector(`[data-game="${activeGame}"]`).classList.remove('active');
                    }
                    
                    document.body.style.overflow = 'hidden'; 
                    activeGame = gameName;
                    win.classList.add('active');
                    game.start();
                });
            });
        });
    </script>
</body>
</html>
